package comp1140.ass2;

import comp1140.ass2.gittest.A;

import java.lang.reflect.Array;
import java.util.*;


public class Board {

    /*100 100 is origin, Array of all the tiles appearing on the surface*/
    private Tile[][] surfaceTiles = new Tile[200][200];

    /*Player ID 0 to P-1 inclusive, P is number of players*/
    private final int player;

    private int stonesInHold;

    private int boardRadiusX;
    private int boardRadiusY;

    /**Constructs board form internal objects.
     * @author u7646615
     *
     * @param player the player id of the player that owns this board
     * */
    public Board(int player) {
        this.player = player;
        stonesInHold = 0;
        /*Places the initial tiles*/
        this.surfaceTiles[100][100] = new Tile(District.HOUSES, true, 0);
        this.surfaceTiles[101][99] = new Tile(District.QUARRY, false, 0);
        this.surfaceTiles[100][101] = new Tile(District.QUARRY, false, 0);
        this.surfaceTiles[99][99] = new Tile(District.QUARRY, false, 0);
        //Default to max now, will change in future
        boardRadiusX = 2;
        boardRadiusY = 2;
    }

    /**Constructs board from String.
     * @author u7646615
     *
     * @param player the player id of the player that owns this board
     * @param movesString the string representing the moves applied to this board*/
    public Board(int player, String movesString) {
        this.player = player;
        this.stonesInHold = 0;
        /*Converts string of moves into Array of move objects*/
        Move[] move = movesFromString(movesString);
        /*Places the initial tiles*/
        this.surfaceTiles[100][100] = new Tile(District.HOUSES, true, 0);
        this.surfaceTiles[101][99] = new Tile(District.QUARRY, false, 0);
        this.surfaceTiles[100][101] = new Tile(District.QUARRY, false, 0);
        this.surfaceTiles[99][99] = new Tile(District.QUARRY, false, 0);
        this.boardRadiusX = 2;
        this.boardRadiusY = 2;
        /*Makes all the moves listed in the moveString*/
        for (int i = 0; i < move.length; i++) {
            placePiece(move[i], true);
        }
    }

    /**Converts string representing several moves into an Array of move objects.
     * @author u7646615
     *
    * @param moveString the part of the gameString describing all the moves the player has made
    * @return Move[] Array containing the moves this string represents in the same order*/
    private Move[] movesFromString (String moveString) {
        Move[] moves = new Move[Math.floorDiv( moveString.length(),10)];
        for (int i = 0; i < moves.length; i++) {
            moves[i] = new Move(moveString.substring(i*10,i*10+10));
        }
        return moves;
    }
    /**Places piece on Board.
     * @author u7646615
     * <p>
     * Will not place pieces that cannot be legally placed.
     * Will keep track of any stones generated by placing piece over a quarry.
     * Ensures piece is placed at correct height
     *
    * @param moveToMake the move to be reflected on the board
     *@param setup true when the method is called by the constructor. Stones already generated should not be counted
     **/
    public void placePiece(Move moveToMake, boolean setup){
        HexCoord[] tilePositions = findTilePosition(moveToMake);
        Tile[] tiles = moveToMake.getPiece().getTiles();
        for (int i = 0; i < 3; i++) {
            /*Sets the tile's height as one below the tile above it*/
            if (getTile(tilePositions[i]) != null) {
                tiles[i].setHeight(getTile(tilePositions[i]).getHeight() + 1);
                if (getTile(tilePositions[i]).getDistrictType() == District.QUARRY && !setup) {
                    stonesInHold ++;
                }
            }
            //We update board active board radius as pieces are placed. This makes checks much faster.
            if (Math.abs(tilePositions[i].getY()) > boardRadiusY) {
                boardRadiusY = Math.abs(tilePositions[i].getY());
            }
            if (Math.abs(tilePositions[i].getX()) > boardRadiusX) {
                boardRadiusX = Math.abs(tilePositions[i].getX());
            }
            this.surfaceTiles[100+tilePositions[i].getX()][100+tilePositions[i].getY()] = tiles[i];
        }
    }

    /**
     * Given a piece returns the position that each tile will be placed.
     * @author u7646615
     * <p>
    * The order of the positions is the same as the order of tiles
     *
    * @param moveToMake, the move for which all the tile positions will be returns
    * @return HexCoord[] an array containing the positions of each piece*/
    private HexCoord[] findTilePosition (Move moveToMake) {
        HexCoord[] tilePosition = new HexCoord[3];
        HexCoord basePos = moveToMake.getPosition().getPos();
        tilePosition[0] = basePos;
        /*Offset to account for hexagonal grid, odd and even columns are shifted from each other*/
        int offset = 0;
        if (Math.abs(basePos.getX()) % 2 == 1) {
            offset = 1;
        }
        switch (moveToMake.getPosition().getRot()) {
            case DEG_0:
                tilePosition[1] = basePos.add(new HexCoord(0,1));
                tilePosition[2] = basePos.add(new HexCoord(1,offset));
                break;
            case DEG_60:
                tilePosition[1] = basePos.add(new HexCoord(1,offset));
                tilePosition[2] = basePos.add(new HexCoord(1,-1+offset));
                break;
            case DEG_120:
                tilePosition[1] = basePos.add(new HexCoord(1,-1+offset));
                tilePosition[2] = basePos.add(new HexCoord(0,-1));
                break;
            case DEG_180:
                tilePosition[1] = basePos.add(new HexCoord(0,-1));
                tilePosition[2] = basePos.add(new HexCoord(-1,-1+offset));
                break;
            case DEG_240:
                tilePosition[1] = basePos.add(new HexCoord(-1,-1+offset));
                tilePosition[2] = basePos.add(new HexCoord(-1,offset));
                break;
            case DEG_300:
                tilePosition[1] = basePos.add(new HexCoord(-1,offset));
                tilePosition[2] = basePos.add(new HexCoord(0,1));
                break;
        }
        return tilePosition;
    }

    /** Given a Move will decide if the move can be legally placed on the board.
     * @author u7646615
     * <p>
     * This method does not check if the entire move is legal.
     * It will only test if there position the piece will be placed on is acceptable in the rules
     *
    * @param moveToMake the move being considered
     * @return boolean, true if the piece can be legally placed on the board*/
    public Boolean isValidPlacement(Move moveToMake) {
        HexCoord[] positions = findTilePosition(moveToMake);
        /*Counting to see how many of the pieces hexagons will not cover another piece*/
        int height = placementHeights(positions);
        if (height == -1) {
            return false;
        }

        /*Given the case that the entire piece is on the ground return true if there is an adjacent tile*/
        if (height == 0) {
            for (HexCoord point : moveToMake.getPieceNeighbours()) {
                if (getTile(point) != null) {
                    return true;
                }
            }
            return false;
        }
        int piece0 = getTile(positions[0]).getPiece();
        boolean samePiece = true;
        samePiece = samePiece && (piece0 == getTile(positions[1]).getPiece());
        samePiece = samePiece && (getTile(positions[2]).getPiece() == piece0);
        return !samePiece;
    }

    /** returns height all the pieces wll be placed at.
     * @author u7646615
     * <p>
     * -1 if different height
     *
     * @param piecePositions positions pieces will be placed
     * @return the height at which they will be placed
     * */

    private int placementHeights(HexCoord[] piecePositions) {
        Tile tile0 = getTile(piecePositions[0]);
        int height0;
        if (tile0 != null) {
            height0 = tile0.getHeight() + 1;
        } else {
            height0 = 0;
        }
        Tile tile1 = getTile(piecePositions[1]);
        int height1;
        if (tile1 != null) {
            height1 = tile1.getHeight() + 1;
        } else {
            height1 = 0;
        }
        if (height0 != height1) {
            return -1;
        }

        Tile tile2 = getTile(piecePositions[2]);
        int height2;
        if (tile2 != null) {
            height2 = tile2.getHeight() + 1;
        } else {
            height2 = 0;
        }
        if (height0 != height2) {
            return -1;
        }
        return height0;
    }

    /**
    * Given a hexCoord describing a point of the board will check if it is a part of a lake.
     * @author u7646615
     * <p>
     * A lake is a part of the board where no piece has been placed but is surrounded by tiles
     *
     * @param point the point on the board that will be checked if it is a tile
     * @return boolean, true if it is a lake
     **/
    public boolean isLake(HexCoord point) {
        if (getTile(point) != null) {
            return false;
        }
        /*This quick way of checking if it is not a lake, failing this does not mean that it cannot be a lake*/
        boolean hasReachedEdgeCardinally = false;
        hasReachedEdgeCardinally = hasReachedEdgeCardinally || !cardinalSearchForTile(new HexCoord(0,1),point);
        hasReachedEdgeCardinally = hasReachedEdgeCardinally || !cardinalSearchForTile(new HexCoord(0,-1),point);
        hasReachedEdgeCardinally = hasReachedEdgeCardinally || !cardinalSearchForTile(new HexCoord(1,0),point);
        hasReachedEdgeCardinally = hasReachedEdgeCardinally || !cardinalSearchForTile(new HexCoord(-1,0),point);
        if (hasReachedEdgeCardinally) {
            return false;
        }
        /*This tries to build the largest set of empty coordinates, if it reaches a sie of 20, it will stop adding
        * elements, in this case we assume it is not a lake*/
        Set<HexCoord> noTileGroup = new HashSet<>();
        groupOfNoTiles(point, noTileGroup);
        return noTileGroup.size() > 20;
    }

    /**Checks if a tile is a lake according to the definition of the test cases.
     * @author u7646615
     * <p>
     * The game rules consider empty tiles surrounding by pieces to be a lake.
     * The test case definition requires that a lake be only 1 tile large
     *
     * @param point the point to be tested if it is a lake
     * @return boolean, true if it is a lake
     * */
    public boolean isLakeSingleTile(HexCoord point) {
        // Confirms that the tile is empty
        if (getTile(point) != null) {
            return false;
        }
        // Checks that all neighbours are non-empty
        HexCoord[] neighbours = point.getSurroundings();
        for (HexCoord neighbour : neighbours) {
            if (getTile(neighbour) == null || !withinEdge(neighbour)) {
                return false;
            }
        }
        return true;
    }


    /**
     * searches from a point in a given direction checking if a piece or edge is reached.
     * @author u76466615
     *
     * @param point HexCoord describing the position from where the search will start
     * @param direction HexCoord now acting as a direction, the direction in which the search will move
     *
     * @return boolean, true if tile reached, false if edge reached
     * */
    private boolean cardinalSearchForTile(HexCoord direction, HexCoord point) {
        if (point.getX() < -100 || point.getX() > 99 || point.getY() < -100 || point.getY() > 99) {
            return false;
        }
        if (getTile(point) != null) {
            return true;
        }
        return cardinalSearchForTile(direction, point.add(direction));
    }

    /**
     * Given a point will construct the set of adjacent empty tile.
     * @author u7646615
     * <p>
     * Will terminate once the set has more than 20 elements.
     * Will not add to set when called with point where the tile is not empty.
     *
     * @param point the point from where the all adjacent tiles will be checked.
     * @param noTileGroup the set which collects points reffering to empty tiles.
     * */
    private void groupOfNoTiles(HexCoord point, Set<HexCoord> noTileGroup) {
        if (noTileGroup.size() > 20) {
            return;
        }
        if (getTile(point) != null) {
            return;
        }
        noTileGroup.add(point);
        HexCoord[] neighbours = point.getSurroundings();
        for (HexCoord neighbour : neighbours) {
            if (!containsIdentical(noTileGroup,neighbour)) {
                groupOfNoTiles(neighbour, noTileGroup);
            }
        }
    }

    /**Checks if set of HexCoord contains an identical element to another HexCoord.
     * @author u7646615
     * <p>
     * Does not check if set contains an element, but if it holds an element that is equal to another
     *
     * @param set the set to be checked for identical elements
     * @param element the element that may be equal to an element in the set
     * @return boolean true if the set has an element equal to the element given.
     **/
    private boolean containsIdentical(Set<HexCoord> set, HexCoord element) {
        Iterator<HexCoord> setIterator = set.iterator();
        while (setIterator.hasNext()) {
            if (element.equals(setIterator.next())) {
                return true;
            }
        }
        return false;
    }


    /**
     * returns the stones held by the board, and resets the count.
     * @author u7646615
     *
     * @return int the amount of stones held by the board
     * */
    public int collectStones() {
        int stonesHldr = stonesInHold;
        stonesInHold = 0;
        return stonesHldr;
    }


    /**Given a position will return the tile that is their, or null if no tile there.
     * @author u7646615
     *
    * @param position the position the tile returned is from
     * @return Tile the tile at the position*/
    public Tile getTile (HexCoord position) {
        int xPos = 100 + position.getX();
        int yPos = 100 + position.getY();
        if (xPos > 199 || xPos < 0) {
            return null;
        }
        if (yPos > 199|| yPos < 0) {
            return null;
        }
        return surfaceTiles[xPos][yPos];  // HexCoord is surfaceTile xIndex-100, yIndex-100
    }

    /** Given a position checks if it is in the bounds of the board.
     * @author u7646615
     *
     * @param point the point to be checked if it is in the bounds of the board
     * @return boolean true if it is in the bounds of the board
     * */
    public boolean inBounds(HexCoord point) {
        int xPos = 100 + point.getX();
        int yPos = 100 + point.getY();
        if (xPos > 99 + boardRadiusX + 3 || xPos < 100 - boardRadiusX - 3) {
            return false;
        }
        return yPos > 99 + boardRadiusY + 3|| yPos < 100 - boardRadiusY - 3;
    }

    /**
     * Given a position decides if it is within the maximum possible bounds of the board ([1,199]x[1,199])
     * @author u7646615
     *
     * @param point the point to be checked if it is in the maximum bounds of the board
     * @return boolean true if it is in the maximum bounds of the board
     * */
    private boolean withinEdge(HexCoord point) {
        int xPos = 100 + point.getX();
        int yPos = 100 + point.getY();
        if (xPos > 199 || xPos < 0) {
            return false;
        }
        return yPos > 199 || yPos < 0;
    }

    public int calculateHouseScore(boolean variant) {

        ArrayList<HexCoord> listOfCoords = getTilesOfType(District.HOUSES);

        ArrayList<ArrayList<HexCoord>> foundGroups = new ArrayList<>();

        outerLoop:
        for (int i = 0; i < listOfCoords.size(); i++) {

            for (var group : foundGroups) {
                if (group.contains(listOfCoords.get(i))) {
                    continue outerLoop;
                }
            }

            ArrayList<HexCoord> newGroup = new ArrayList<>();
            newGroup.add(listOfCoords.get(i));
            foundGroups.add(newGroup);
            findSurroundingHouses(newGroup, listOfCoords.get(i));

        }

        System.out.println("Found groups: " + foundGroups.size());

        for (var group : foundGroups) {
            System.out.println(group.size());
        }

        ArrayList<ArrayList<HexCoord>> largestGroups = new ArrayList<>();

        if (foundGroups.size() < 1) {
            return 0;
        }
        largestGroups.add(foundGroups.get(0));

        for (var group : foundGroups) {
            if (group.size() > largestGroups.get(0).size()) {
                System.out.println("Larger");
                largestGroups = new ArrayList<>();
                largestGroups.add(group);
            } else if (group.size() == largestGroups.get(0).size()) {
                largestGroups.add(group);
            }
        }

        System.out.println("Largest: " + largestGroups.get(0).size());

        ArrayList<Integer> largestScores = new ArrayList<>();

        for (var largeGroup : largestGroups) {

            var score = 0;

            for (var coord : largeGroup) {
                var tile = getTile(coord);
                var tileHeight = tile.getHeight();

                if (!tile.getPlaza())  {
                    score += (tileHeight + 1);
                }
            }

            if (variant && score >= 10) {
                score *= 2;
            }

            largestScores.add(score);
        }

        var largestScore = largestScores.get(0);

        for (var score : largestScores) {
            if (score > largestScore) {
                largestScore = score;
            }
        }

        var stars = starCount(District.HOUSES);

        System.out.println("Stars: " + stars);
        return largestScore * stars;

    }


    private void findSurroundingHouses(ArrayList<HexCoord> housesInGroup, HexCoord currentCoord) {

        var surrounds = currentCoord.getSurroundings();

        for (int i = 0; i < surrounds.length; i++) {
            var surroundingTile = getTile(surrounds[i]);
            if (!housesInGroup.contains(surrounds[i]) && surroundingTile != null && surroundingTile.getDistrictType().equals(District.HOUSES) && !surroundingTile.getPlaza()) {
                housesInGroup.add(surrounds[i]);
                findSurroundingHouses(housesInGroup, surrounds[i]);
            }
        }
    }

    public int calculateHouseScore1(boolean variant) {
        if (!variant) {

            // Initialize the houses and houseStars to be zero for each player
            int totalHouseStars = 0;
            int totalValidHouses = 0;



            ArrayList<ArrayList<HexCoord>> mergeList = splitHouseTiles();

            var mergeFlag = true;

            while (mergeFlag == true) {

                mergeFlag = false;

                if (mergeList.size() % 2 == 1) {
                    System.out.println("Odd");
                }

                for (int i = 0; i < mergeList.size(); i = i+2) {
                    var firstList = mergeList.get(i);
                    ArrayList<HexCoord> secondList;
                    if (i + 1 >= mergeList.size()) {
                        secondList = mergeList.get(0);
                    } else {
                        secondList = mergeList.get(i+1);
                    }


                    System.out.println(firstList.size() + "  1");
                    System.out.println(secondList.size() + "  2");

                    ArrayList<HexCoord> surroundsList = new ArrayList<>();

                    for (int j = 0; j < firstList.size(); j++) {
                        var surrounds = firstList.get(j).getSurroundings();
                        for (int k = 0; k < surrounds.length; k++) {
                            surroundsList.add(surrounds[k]);
                        }
                    }

                    for (int j = 0; j < surroundsList.size(); j++) {

                        System.out.println(surroundsList.get(j) + " " + i);

                        for (var coord : secondList) {
                            if (coord.equals(surroundsList.get(j))) {
                                merge(mergeList, firstList, secondList);
                                mergeFlag = true;
                            }
                        }
                    }
                }
            }

            System.out.println("Done");

            ArrayList<HexCoord> largestGroup = mergeList.get(0);

            for (var group : mergeList) {
                if (group.size() > largestGroup.size()) {
                    largestGroup = group;
                }
            }




            for (var coord : largestGroup) {
                System.out.println(coord);

                totalValidHouses += getTile(coord).getHeight();
            }

            System.out.println(totalValidHouses);


            return starCount(District.HOUSES) * totalValidHouses;
        }
        return 5;
    }

    private ArrayList<HexCoord> getTilesOfType(District district) {

        ArrayList<HexCoord> listOfCoords = new ArrayList<>();

        for (int i = 0; i < surfaceTiles.length; i++) {
            for (int j = 0; j < surfaceTiles[i].length; j++) {
                var tile = surfaceTiles[i][j];
                if (tile != null && tile.getDistrictType().equals(district) && !tile.getPlaza()) {
                    listOfCoords.add( new HexCoord(i-100, j-100));
                }
            }
        }
        return listOfCoords;
    }

    private void merge(ArrayList<ArrayList<HexCoord>> mergeList, ArrayList<HexCoord> firstList, ArrayList<HexCoord> secondList) {
        for (int i = 0; i < secondList.size(); i++) {
            if (!firstList.contains(secondList.get(i))) {
                firstList.add(secondList.get(i));
            }
        }
        mergeList.remove(secondList);
        System.out.println("Merge");
    }

    private ArrayList<ArrayList<HexCoord>> splitHouseTiles() {

        ArrayList<ArrayList<HexCoord>> mergeList = new ArrayList<>();

        for (int i = 0; i < surfaceTiles.length; i++) {
            for (int j = 0; j < surfaceTiles[i].length; j++) {
                if (surfaceTiles[i][j] != null && surfaceTiles[i][j].getDistrictType().equals(District.HOUSES)) {
                    ArrayList<HexCoord> singleTile = new ArrayList<>();
                    singleTile.add(new HexCoord(i -100, j-100));
                    mergeList.add(singleTile);
                }
            }
        }

        return mergeList;
    }

    private int starCount(District district) {
        int stars = 0;
        for (int i = 0; i < surfaceTiles.length; i++) {
            for (int j = 0; j < surfaceTiles[i].length; j++) {
                if (surfaceTiles[i][j] != null && surfaceTiles[i][j].getDistrictType().equals(district)) {
                    if (surfaceTiles[i][j].getPlaza()) {
                        stars += surfaceTiles[i][j].getStars(surfaceTiles[i][j]);
                    }
                }
            }
        }
        return stars;
    }

    private boolean mergeSet(HashSet<Tile> set, ArrayList<HashSet<Tile>> mergeSetList) {
        for (var tile : set) {

            var surrounds = getAdjacentTiles(tile);

            for(var otherSet : mergeSetList) {
                if (!otherSet.equals(set)) {
                    for (var adjacentTile : surrounds) {
                        if (otherSet.contains(adjacentTile)) {
                            for (var otherTile : otherSet) {
                                set.add(otherTile);
                            }
                            mergeSetList.remove(otherSet);
                            return true;
                        }
                    }
                }
            }
        }
        return false;
    }


    
    public ArrayList<Tile> getAdjacentTiles(Tile tile) {

        ArrayList<Tile> adjacentTiles = new ArrayList<>();

        for (int i = 0; i < surfaceTiles.length; i++) {
            for (int j = 0; j < surfaceTiles[i].length; j++) {
                if (tile.equals(surfaceTiles[i][j])) {
                    var surroundingHexes = (new HexCoord(i-100, j-100)).getSurroundings();
                    for (HexCoord surroundingHex : surroundingHexes) {
                        adjacentTiles.add(getTile(surroundingHex));
                    }
                }
            }
        }
        return adjacentTiles;
    }

    public Tile[][] getSurfaceTiles() {
        return surfaceTiles;
    }

    public int getBoardRadiusX() {
        return boardRadiusX;
    }

    public int getBoardRadiusY() {
        return boardRadiusY;
    }
}
